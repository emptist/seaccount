// Generated by CoffeeScript 1.10.0
var ClientAccount, FundAccount, HSClientAccount, IBClientAccount, Position, util,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

util = require('util');

FundAccount = require('./fund');

ClientAccount = (function() {
  function ClientAccount(broker, id, password) {
    this.broker = broker;
    this.id = id;
    this.password = password;
  }

  return ClientAccount;

})();

IBClientAccount = (function(superClass) {
  extend(IBClientAccount, superClass);

  function IBClientAccount() {
    return IBClientAccount.__super__.constructor.apply(this, arguments);
  }

  return IBClientAccount;

})(ClientAccount);


/* 注意:
  所有英文方法,多是兼容現有Python接口所需,將來會全部改為中文標準名詞

  TODO:
  1. 資產和持倉與前面比較,制定止損
  2. 持倉比重均攤,超額則賣出(完成),買入時也自動均衡
  3. 分解成單幣種賬戶,分別管理
 */

HSClientAccount = (function(superClass) {
  extend(HSClientAccount, superClass);

  function HSClientAccount(broker, id, password, servicePassword) {
    this.broker = broker;
    this.id = id;
    this.password = password;
    this.servicePassword = servicePassword;
    this.求各幣資產 = bind(this.求各幣資產, this);
    this.求資產賬戶 = bind(this.求資產賬戶, this);
    this.資產賬戶 = {};
    this.黑名單 = [];
    this.可售 = [];
    this.現有 = [];
    this.前持倉 = null;
    this.資產 = null;
    this.前資產 = null;
    this.持倉 = null;
    this.比重上限 = 0.5;
    this.最小分倉資金量 = 20000;
  }

  HSClientAccount.prototype.操作指令 = function(obj, 回執) {

    /*過濾操作指令
    
      回執
        obj: 操作指令string
      或
        null
     */
    return 回執((function() {
      var ref;
      switch (obj.操作) {
        case 'cancelIt':
          return obj;
        case 'buyIt':

          /*
          須逐步實現以下買入控制:
            1. 排除黑名單
            1. 調整買入數量,令不超比例
            1. 檢查委託價格
            1. 回報成交狀態
           */
          if (ref = obj.代碼, indexOf.call(this.黑名單, ref) >= 0) {
            return null;
          } else {
            return this.求資產賬戶(obj.代碼).買入評估(obj);

            /*
            if obj.代碼 in @現有
              額度 = Math.min(@求剩餘額度(obj.代碼), obj.比重)
              if 額度 < 0
                null
              else
                obj.比重 = 額度
                obj
            else # 還須 等分資金,控制剩餘資金是否購買,不夠須調整比重.等等.
              obj
             */
          }
          break;
        case 'sellIt':
          return this.求資產賬戶(obj.代碼).賣出評估(obj);

          /*
          if obj.代碼 in @可售
             obj
          else null
           */
        default:
          return null;
      }
    }).call(this));
  };

  HSClientAccount.prototype.查詢簡況 = function(data, callback) {
    return this.查詢持倉(data, callback);
  };

  HSClientAccount.prototype.查詢持倉 = function(data, callback) {
    var key, ref, ref1, results, tick, value, 品種;
    ref = this.資產賬戶;
    for (key in ref) {
      value = ref[key];
      value.更新持倉();
    }
    this.現有 = [];
    this.可售 = [];
    this.持倉 = {};

    /* 此處可對不同類型品種設置不同的止損比重率,
      或可在證券中設定,但每個賬戶的風險控制不同,故應因人制宜
     */
    for (key in data) {
      tick = data[key];

      /*
      代碼 = tick.SecurityCode
      可用數量 = tick.SecurityAvail
      現有數量 = tick.SecurityAmount
      浮動盈虧 = tick.Profit
      @持倉[代碼] = tick
      if 現有數量 > 0
        @現有.push 代碼
      if 可用數量 > 0
        @可售.push 代碼
        if 浮動盈虧 < 0
          command = "sellIt,#{代碼},#{@求止損比重(代碼)},#{tick.LastPrice}"
          callback(command)
        else
          比重 = @應減倉比重(代碼)
          if 比重 > 0
            command = "sellIt,#{代碼},#{比重},#{tick.LastPrice}"
            callback(command)
       */
      品種 = new Position();
      品種.華泰品種(tick);
      this.求資產賬戶(品種.代碼).更新品種(品種, this, callback);
    }
    if (this.前持倉 == null) {
      this.前持倉 = this.持倉;
      ref1 = this.資產賬戶;
      results = [];
      for (key in ref1) {
        value = ref1[key];
        results.push(value.記錄前持倉());
      }
      return results;
    }
  };


  /*
    按照目前設計, 此處 回執 不要用
   */

  HSClientAccount.prototype.查詢資產 = function(data, 回執) {
    var key, value;
    for (key in data) {
      value = data[key];
      if (this.資產賬戶[key] == null) {
        this.資產賬戶[key] = new FundAccount(this.id);
      }
      this.資產賬戶[key].記錄資產(value);
    }
    this.資產 = data;
    if (this.前資產 == null) {
      return this.前資產 = data;
    }
  };

  HSClientAccount.prototype.查可撤單 = function(data, callback) {
    return util.log("got orders data", data);
  };

  HSClientAccount.prototype.求資產賬戶 = function(代碼) {
    var 幣種;
    幣種 = (function() {
      switch (代碼[0]) {
        case '9':
          return '1';
        case '2':
          return '2';
        default:
          return '0';
      }
    })();
    return this.資產賬戶[幣種];
  };

  HSClientAccount.prototype.求止損比重 = function(代碼) {
    return 0.618;
  };

  HSClientAccount.prototype.求各幣資產 = function(代碼) {
    return this.求資產賬戶[代碼].資產;
  };

  HSClientAccount.prototype.求市值 = function(代碼) {
    return this.持倉[代碼].HoldingValue;
  };

  HSClientAccount.prototype.求總額 = function(代碼) {
    return this.求各幣資產(代碼).TotalAsset;
  };


  /* 查閱資產和持倉狀況,計算該證券比重,對照比重限額,回復是否超重
   */

  HSClientAccount.prototype.超重 = function(代碼) {
    return this.求市值(代碼) / this.求總額(代碼) > this.比重上限;
  };

  HSClientAccount.prototype.求剩餘額度 = function(代碼) {
    return this.比重上限 - (this.求市值(代碼) / this.求總額(代碼));
  };

  HSClientAccount.prototype.應減倉比重 = function(代碼, 均勻) {
    if (均勻 == null) {
      均勻 = false;
    }
    if ((this.求各幣資產(代碼).rmb_value) < this.最小分倉資金量()) {
      return 0;
    } else if (均勻) {
      return (this.求市值(代碼) / this.求總額(代碼)) - (1 / this.現有.length);
    } else {
      return (this.求市值(代碼) / this.求總額(代碼)) - this.比重上限;
    }
  };

  return HSClientAccount;

})(ClientAccount);

Position = (function() {
  function Position(代碼1) {
    this.代碼 = 代碼1;
  }

  Position.prototype.華泰品種 = function(va) {
    this.序號 = va.index;
    this.平均買入價 = va.av_buy_price;
    this.平均收支平衡 = va.av_income_balance;
    this.成本價 = va.CostPrice;
    this.持倉股數 = va.SecurityAmount;
    this.可售股數 = va.SecurityAvail;
    this.交易所 = va.exchange_name;
    this.交易所類號 = va.exchange_type;
    this.標識 = va.hand_flag;
    this.盈虧 = va.Profit;
    this.盈虧百分比 = va.income_balance_ratio;
    this.保本價 = va.keep_cost_price;
    this.最近價 = va.LastPrice;
    this.持倉市值 = va.HoldingValue;
    this.股東賬號 = va.stock_account;
    this.代碼 = va.SecurityCode;
    this.名稱 = va.SecurityName;
    this.超額 = va.extra;
    return this;
  };

  return Position;

})();

module.exports = {
  HSClientAccount: HSClientAccount
};

//# sourceMappingURL=account.js.map
